Index: helpers.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import numpy as np\r\nfrom scipy import signal\r\n\r\n\r\ndef bin_z(f, dz, factor: int = 2):\r\n    nz, ny, nx = f.shape\r\n    nz = factor * (nz // factor)  # Enforce consistency\r\n\r\n    f = np.sum(np.reshape(f[:nz, :, :], (factor, -1), order='F'), axis=0)\r\n\r\n    return np.reshape(f, (-1, ny, nx), order='F'), dz * factor  # Don't forget to update dz\r\n\r\n\r\ndef crop_xy(f, factor: int = 2):\r\n    _, ny, nx = f.shape\r\n\r\n    dny = max(1, ny // (2 * factor))\r\n    dnx = max(1, nx // (2 * factor))\r\n\r\n    return f[:, (ny // 2 - dny):(ny // 2 + dny), (nx // 2 - dnx):(nx // 2 + dnx)]\r\n\r\n\r\ndef crop_z(f, factor: int = 2):\r\n    nz, _, _ = f.shape\r\n\r\n    dnz = max(1, nz // factor)\r\n\r\n    return f[:dnz, :, :]\r\n\r\n\r\ndef amorphous_sample(nz=2000, ny=480, nx=None, seed=None, amplitude=15.):\r\n    if nx is None:\r\n        nx = ny + 0\r\n\r\n    rand_gen = np.random.default_rng(seed=seed)\r\n\r\n    return amplitude * rand_gen.random((nz, ny, nx)) ** 5  # Dirty approx. of an amorphous sample\r\n\r\n\r\ndef fft2(f):\r\n    return np.fft.fftshift(np.fft.fft2(np.fft.ifftshift(f), norm='ortho'))\r\n\r\n\r\ndef ifft2(f):\r\n    return np.fft.fftshift(np.fft.ifft2(np.fft.ifftshift(f), norm='ortho'))\r\n\r\n\r\ndef bandwidth_limit(cfg):\r\n    # The outer 3rd needs to be zero'd to prevent wrap-around artifacts\r\n    n = cfg.shape[2]\r\n    x = np.arange(0, n) - n // 2\r\n    rsq = x[:, None] ** 2 + x[None, :] ** 2\r\n\r\n    return np.asarray(rsq < (.33 * n) ** 2, dtype=float)\r\n\r\n\r\ndef crop_dp(dp, cfg):\r\n    # crop the area away that has been zero'd in the bandwidth limitation step\r\n\r\n    n = cfg.shape[-1]\r\n    dn = n // 3 + 1\r\n\r\n    return dp[(n // 2 - dn):(n // 2 + dn), (n // 2 - dn):(n // 2 + dn)]\r\n\r\n\r\ndef propagator(cfg):  # In Fourier space\r\n    # usq = u**2 + v**2, with u and v coordinates in Fourier space\r\n\r\n    n = cfg.shape[-1]\r\n    u = cfg.du * (np.arange(0, n) - n // 2)\r\n    usq = u[:, None] ** 2 + u[None, :] ** 2\r\n\r\n    return np.exp(-1.j * np.pi * cfg.lam * cfg.dz * usq)\r\n\r\n\r\ndef diffraction_pattern(psi, cfg):\r\n    # psi = multislice(potential, cfg)  # Calculate the exit wave of the sample\r\n\r\n    dp = np.abs(fft2(psi)) ** 2  # Convert to diffraction space and intensities\r\n\r\n    return crop_dp(dp, cfg)\r\n\r\n\r\nLAPLACIAN_KERNEL = 1 / 4 * np.array([[1, 2, 1], [2, -12, 2], [1, 2, 1]])\r\nBOUNDARY_MODE = \"symm\"\r\nCONVOLVE_MODE = \"same\"\r\n\r\n\r\ndef laplace(f):\r\n    return signal.convolve2d(f, LAPLACIAN_KERNEL, boundary=BOUNDARY_MODE, mode=CONVOLVE_MODE)\r\n\r\n\r\ndef laplace_n(f, n):\r\n    out = f.copy()  # might be inefficient, but assignment is required I think (Luc)\r\n    for _ in range(n):\r\n        out = signal.convolve2d(f, LAPLACIAN_KERNEL, boundary=BOUNDARY_MODE, mode=CONVOLVE_MODE)\r\n    return out\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/helpers.py b/helpers.py
--- a/helpers.py	(revision 0350faff67c49af3de49e75db76320eb12264231)
+++ b/helpers.py	(date 1762340851935)
@@ -1,8 +1,11 @@
+import math
+
 import numpy as np
 from scipy import signal
 
 
 def bin_z(f, dz, factor: int = 2):
+
     nz, ny, nx = f.shape
     nz = factor * (nz // factor)  # Enforce consistency
 
@@ -34,49 +37,53 @@
 
     rand_gen = np.random.default_rng(seed=seed)
 
-    return amplitude * rand_gen.random((nz, ny, nx)) ** 5  # Dirty approx. of an amorphous sample
+    return amplitude * rand_gen.random((nz, ny, nx))**5  # Dirty approx. of an amorphous sample
 
 
 def fft2(f):
+
     return np.fft.fftshift(np.fft.fft2(np.fft.ifftshift(f), norm='ortho'))
 
 
 def ifft2(f):
+
     return np.fft.fftshift(np.fft.ifft2(np.fft.ifftshift(f), norm='ortho'))
 
 
 def bandwidth_limit(cfg):
+
     # The outer 3rd needs to be zero'd to prevent wrap-around artifacts
     n = cfg.shape[2]
-    x = np.arange(0, n) - n // 2
-    rsq = x[:, None] ** 2 + x[None, :] ** 2
+    x = np.arange(0, n) - n//2
+    rsq = x[:, None]**2 + x[None, :]**2
 
-    return np.asarray(rsq < (.33 * n) ** 2, dtype=float)
+    return np.asarray(rsq < (.33 * n)**2, dtype=float)
 
 
 def crop_dp(dp, cfg):
     # crop the area away that has been zero'd in the bandwidth limitation step
 
     n = cfg.shape[-1]
-    dn = n // 3 + 1
+    dn = n//3 + 1
 
-    return dp[(n // 2 - dn):(n // 2 + dn), (n // 2 - dn):(n // 2 + dn)]
+    return dp[(n//2 - dn):(n//2 + dn), (n//2 - dn):(n//2 + dn)]
 
 
 def propagator(cfg):  # In Fourier space
     # usq = u**2 + v**2, with u and v coordinates in Fourier space
 
     n = cfg.shape[-1]
-    u = cfg.du * (np.arange(0, n) - n // 2)
-    usq = u[:, None] ** 2 + u[None, :] ** 2
+    u = cfg.du * (np.arange(0, n) - n//2)
+    usq = u[:, None]**2 + u[None, :]**2
 
     return np.exp(-1.j * np.pi * cfg.lam * cfg.dz * usq)
 
 
 def diffraction_pattern(psi, cfg):
+
     # psi = multislice(potential, cfg)  # Calculate the exit wave of the sample
 
-    dp = np.abs(fft2(psi)) ** 2  # Convert to diffraction space and intensities
+    dp = np.abs(fft2(psi))**2  # Convert to diffraction space and intensities
 
     return crop_dp(dp, cfg)
 
@@ -95,3 +102,17 @@
     for _ in range(n):
         out = signal.convolve2d(f, LAPLACIAN_KERNEL, boundary=BOUNDARY_MODE, mode=CONVOLVE_MODE)
     return out
+
+
+def factorial_power(x, n):
+    # Computes the factorial power function of x^(n)
+    result = 1
+    for i in range(n):
+        result *= x - i
+
+    return result
+
+
+def root_series(a, b, c, n):
+    # Computes the nth order term of the Taylor series of a*sqrt(b+cx)
+    return a * b**(1/2 - n) * c**n * factorial_power(1/2, n) / math.factorial(n)
Index: standalone_multislice.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># Author: Wouter Van den Broek [1]\r\n# Data cube with potential: Holger Kohr [1]\r\n# [1] Thermo Fisher Scientific, Eindhoven, The Netherlands, October 2025.\r\n# License: CC BY-NC-ND, https://creativecommons.org/licenses/by-nc-nd/4.0/\r\n\r\n# backend for graphic generation\r\nimport numpy as np\r\nimport matplotlib\r\nfrom helpers import laplace\r\nmatplotlib.use(\"Qt5Agg\")\r\n\r\n# use path from .env\r\nfrom dotenv import load_dotenv\r\nimport os\r\nload_dotenv()\r\npath = os.getenv(\"POT_PATH\")\r\n\r\nclass Settings:\r\n\r\n    def __init__(self,\r\n                 ht: float = 100.,  # [kV] 'high tension,' a.k.a. acceleration voltage\r\n                 alpha: float = 20.,  # [mrad] convergence angle\r\n                 shape: tuple = (2000, 480, 480),  # shape of the potential array: z, y and x direction\r\n                 dx: float = 20.6,  # [pm] sample size in y and x direction\r\n                 dz: float = None,  # [pm] sample size in z direction\r\n                 ):\r\n\r\n        self.ht = ht\r\n        self.alpha = alpha\r\n        self.shape = shape\r\n        if self.shape[1] != self.shape[2]:\r\n            print('x- and y-dimensions must be equal!')\r\n            self.shape = None  # Make it crash\r\n        self.dx = dx\r\n        if dz is None:\r\n            self.dz = dx\r\n        else:\r\n            self.dz = dz\r\n        self.du = None  # Pixel size in reciprocal space\r\n\r\n        self.htr = None  # Relativistic acceleration voltage\r\n        self.lam = None  # Electron wavelength\r\n        self.width = None  # Lateral width of the beam\r\n        self.dof = None  # Depth of focus, i.e. vertical beam width\r\n        self.sigma = None  # Interaction parameter\r\n        self.aperture = None  # Beam-forming aperture in reciprocal space\r\n        self.probe = None  # Wavefunction of the probe\r\n\r\n        self.initialize()\r\n\r\n    def initialize(self):\r\n        self.alpha *= 1e-3  # [rad] Transform from mrad to rad\r\n        self.ht *= 1e3  # [V] Transform high tension to Volts\r\n        self.dx *= 1e-3  # Transform to nm\r\n        self.dz *= 1e-3  # Transform to nm\r\n        self.du = 1. / (self.shape[-1] * self.dx)  # [1/nm]\r\n        self.set_relativistic_voltage()  # Set the relativistic voltage htr\r\n        self.set_wavelength()  # [nm] Wavelength of the electron\r\n        self.set_beam_width()  # [nm] Width of the beam, spatial resolution.\r\n        self.set_depth_of_field()  # [nm]\r\n        self.set_interaction_parameter()  # [1/nm/V] Interaction parameter\r\n        self.set_aperture()  # Precompute the aperture\r\n        self.set_probe()  # Precompute the probe\r\n\r\n    def set_relativistic_voltage(self):\r\n        self.htr = self.ht * (1. + self.ht * 0.9784755918e-6)\r\n\r\n    def set_wavelength(self):\r\n        self.lam = 1.22642596588 / np.sqrt(self.htr)\r\n\r\n    def set_beam_width(self):\r\n        self.width = .50 * self.lam / self.alpha  # Diffraction limit\r\n\r\n    def set_depth_of_field(self):\r\n        self.dof = 2. * self.lam / self.alpha ** 2\r\n\r\n    def set_interaction_parameter(self):\r\n        mec2 = 0.5109989500e6  # [eV]\r\n        self.sigma = 2. * np.pi * ((mec2 + self.ht) / (2. * mec2 + self.ht)) / (self.lam * self.ht)\r\n\r\n    def set_aperture(self):\r\n        n = self.shape[-1]\r\n        u = self.du * (np.arange(0, n) - n//2)\r\n        usq = u[:, None]**2 + u[None, :]**2\r\n        self.aperture = np.zeros_like(usq)\r\n        self.aperture[usq < (self.alpha / self.lam)**2] = 1.\r\n\r\n    def set_probe(self):\r\n        self.probe = ifft2(self.aperture / np.sum(self.aperture**2))\r\n\r\n\r\ndef bin_z(f, dz, factor: int = 2):\r\n\r\n    nz, ny, nx = f.shape\r\n    nz = factor * (nz // factor)  # Enforce consistency\r\n\r\n    f = np.sum(np.reshape(f[:nz, :, :], (factor, -1), order='F'), axis=0)\r\n\r\n    return np.reshape(f, (-1, ny, nx), order='F'), dz * factor  # Don't forget to update dz\r\n\r\n\r\ndef crop_xy(f, factor: int = 2):\r\n\r\n    _, ny, nx = f.shape\r\n\r\n    dny = max(1, ny // (2 * factor))\r\n    dnx = max(1, nx // (2 * factor))\r\n\r\n    return f[:, (ny//2 - dny):(ny//2 + dny), (nx//2 - dnx):(nx//2 + dnx)]\r\n\r\n\r\ndef crop_z(f, factor: int = 2):\r\n\r\n    nz, _, _ = f.shape\r\n\r\n    dnz = max(1, nz // factor)\r\n\r\n    return f[:dnz, :, :]\r\n\r\n\r\ndef amorphous_sample(nz=2000, ny=480, nx=None, seed=None, amplitude=15.):\r\n\r\n    if nx is None:\r\n        nx = ny + 0\r\n\r\n    rand_gen = np.random.default_rng(seed=seed)\r\n\r\n    return amplitude * rand_gen.random((nz, ny, nx))**5  # Dirty approx. of an amorphous sample\r\n\r\n\r\ndef fft2(f):\r\n\r\n    return np.fft.fftshift(np.fft.fft2(np.fft.ifftshift(f), norm='ortho'))\r\n\r\n\r\ndef ifft2(f):\r\n\r\n    return np.fft.fftshift(np.fft.ifft2(np.fft.ifftshift(f), norm='ortho'))\r\n\r\n\r\ndef bandwidth_limit(cfg):\r\n\r\n    # The outer 3rd needs to be zero'd to prevent wrap-around artifacts\r\n    n = cfg.shape[2]\r\n    x = np.arange(0, n) - n//2\r\n    rsq = x[:, None]**2 + x[None, :]**2\r\n\r\n    return np.asarray(rsq < (.33 * n)**2, dtype=float)\r\n\r\n\r\ndef propagator(cfg):  # In Fourier space\r\n    # usq = u**2 + v**2, with u and v coordinates in Fourier space\r\n\r\n    n = cfg.shape[-1]\r\n    u = cfg.du * (np.arange(0, n) - n//2)\r\n    usq = u[:, None]**2 + u[None, :]**2\r\n\r\n    return np.exp(-1.j * np.pi * cfg.lam * cfg.dz * usq)\r\n\r\n\r\ndef multislice(potential, cfg):\r\n\r\n    # Precompute the bandwidth limiting mask and the Fresnel propagator\r\n    bwl_msk = bandwidth_limit(cfg)\r\n    prop = propagator(cfg)\r\n\r\n    # The multislice itself is surprisingly simple:\r\n    psi = cfg.probe  # Initialize with the probe function\r\n    for ii in range(cfg.shape[0]):\r\n        tmp = fft2(np.exp(1.j * cfg.sigma * potential[ii, :, :] * cfg.dz) * psi)\r\n        psi = ifft2(tmp * prop * bwl_msk)  # Impinging wave for the next slice\r\n\r\n    return psi\r\n\r\n\r\ndef multislice_alt(potential, cfg):\r\n\r\n    # Precompute the bandwidth limiting mask and the Fresnel propagator\r\n    bwl_msk = bandwidth_limit(cfg)\r\n    prop = propagator(cfg)\r\n\r\n    # The multislice itself is surprisingly simple:\r\n    psi = cfg.probe  # Initialize with the probe function\r\n    for ii in range(cfg.shape[0]):\r\n        tmp = np.exp(1.j * cfg.sigma * potential[ii, :, :] * cfg.dz)*ifft2(fft2(psi)*prop*bwl_msk)\r\n        psi = tmp  # Impinging wave for the next slice\r\n\r\n    return psi\r\n\r\n\r\ndef fds_conv(potential, cfg):\r\n\r\n    # Precompute the bandwidth limiting mask and the Fresnel propagator\r\n    bwl_msk = bandwidth_limit(cfg)\r\n\r\n    # The multislice itself is surprisingly simple:\r\n    psi = np.copy(cfg.probe)  # Initialize with the probe function\r\n    psi_prev = np.zeros_like(cfg.probe)   # Initialize with zeros\r\n\r\n    c_plus = 1+2*np.pi*1j*cfg.dz/cfg.lam\r\n    c_minus = 1-2*np.pi*1j*cfg.dz/cfg.lam\r\n    for ii in range(cfg.shape[0]):\r\n        term1 = laplace(psi)\r\n        term2 = 4 * np.pi * cfg.sigma / cfg.lam * potential[ii, :, :] * psi\r\n        tmp = 1 / c_plus * (2 * psi - cfg.dz**2 * (term1 + term2)) - c_minus / c_plus * psi_prev\r\n        psi_next = np.copy(ifft2(fft2(tmp)*bwl_msk))\r\n\r\n        psi_prev = np.copy(psi)\r\n        psi = np.copy(psi_next)\r\n\r\n    return psi\r\n\r\n\r\ndef fds(potential, cfg):\r\n\r\n    # Precompute the bandwidth limiting mask and the Fresnel propagator\r\n    bwl_msk = bandwidth_limit(cfg)\r\n\r\n    # The multislice itself is surprisingly simple:\r\n    psi = np.copy(cfg.probe)  # Initialize with the probe function\r\n    psi_prev = np.zeros_like(cfg.probe)   # Initialize with zeros\r\n\r\n    Nx, Ny = cfg.shape[1], cfg.shape[2]\r\n    kx = np.fft.fftfreq(Nx, cfg.dx)  # spatial frequencies along x-axis\r\n    ky = np.fft.fftfreq(Ny, cfg.dx)  # spatial frequencies along y-axis\r\n\r\n    KX, KY = np.meshgrid(kx, ky, indexing=\"ij\")\r\n    k = KX**2 + KY**2\r\n\r\n    c_plus = 1+2*np.pi*1j*cfg.dz/cfg.lam\r\n    c_minus = 1-2*np.pi*1j*cfg.dz/cfg.lam\r\n    for ii in range(cfg.shape[0]):\r\n        term1 = ifft2(-4 * np.pi**2 * k * fft2(psi))\r\n        term2 = 4 * np.pi * cfg.sigma / cfg.lam * potential[ii, :, :] * psi\r\n        tmp = 1 / c_plus * (2 * psi - cfg.dz**2 * (term1 + term2)) - c_minus / c_plus * psi_prev\r\n        psi_next = np.copy(ifft2(fft2(tmp)*bwl_msk))\r\n\r\n        psi_prev = np.copy(psi)\r\n        psi = np.copy(psi_next)\r\n\r\n    return psi\r\n\r\n\r\ndef crop_dp(dp, cfg):\r\n    # crop the area away that has been zero'd in the bandwidth limitation step\r\n\r\n    n = cfg.shape[-1]\r\n    dn = n//3 + 1\r\n\r\n    return dp[(n//2 - dn):(n//2 + dn), (n//2 - dn):(n//2 + dn)]\r\n\r\n\r\ndef diffraction_pattern(potential, cfg):\r\n\r\n    psi = fds_conv(potential, cfg)  # Calculate the exit wave of the sample\r\n\r\n    dp = np.abs(fft2(psi))**2  # Convert to diffraction space and intensities\r\n\r\n    return crop_dp(dp, cfg)\r\n\r\n\r\nif __name__ == '__main__':\r\n\r\n    import matplotlib.pyplot as plt\r\n\r\n    dx = 20.6  # [pm]\r\n    dz = dx + 0.  # same as dx\r\n\r\n    # Read in your potential here:\r\n    potential = np.load(path)\r\n\r\n    # Optional: another array for testing:\r\n    # potential = amorphous_sample(seed=31415)  # Set the seed so the potential is the same between runs\r\n\r\n    # Bin the z-direction to test various dz samplings:\r\n    # potential, dz = bin_z(potential, dz, factor=10)\r\n    # Optional: select inner quarter to compute faster during testing by cropping the x- and y-directions\r\n    potential = crop_xy(potential, factor=1)\r\n    # Crop the z-direction if needed\r\n    potential = crop_z(potential, factor=20)\r\n\r\n    settings = Settings(ht=100.,  # [kV] 'high tension,' a.k.a. acceleration voltage.  Vary between 10. and 100.\r\n                        # The size and dx of the provided potential are optimized for alpha=20. Keep fixed, especially\r\n                        # in the beginning of the assignment! Later you can vary between 10. and 30. if you're curious.\r\n                        alpha=20.,  # [mrad] convergence angle, 20. is the default.\r\n                        shape=potential.shape,  # shape of the potential array: z-, y- and x-direction\r\n                        dx=dx,  # [pm] sampling size in y and x direction\r\n                        dz=dz,  # [pm] sampling size in z direction, same as dx when None\r\n                        )\r\n\r\n    print(settings.dx, settings.dz, potential.shape, settings.sigma)\r\n\r\n    # Compute the pattern\r\n    pattern = diffraction_pattern(potential, settings)\r\n\r\n    print(np.array(pattern).shape)\r\n\r\n    # Show the results\r\n    _, ax = plt.subplots(2, 2)\r\n    ax[0, 0].imshow(np.abs(settings.probe)**2, cmap='gray', interpolation='nearest')\r\n    ax[0, 0].set_title('Electron probe')\r\n    ax[0, 1].imshow(np.sum(potential, axis=0) * settings.sigma * settings.dz, cmap='gray', interpolation='nearest')\r\n    ax[0, 1].set_title('Projected potential in radians')\r\n    ax[1, 0].imshow(pattern, cmap='gray', interpolation='nearest')\r\n    ax[1, 0].set_title('Diffraction pattern (linear gray scale)')\r\n    ax[1, 1].imshow(np.log(1e9 * np.abs(pattern) + 1.), cmap='gray', interpolation='nearest')\r\n    ax[1, 1].set_title('Diffraction pattern (logarithmic gray scale)')\r\n    plt.show()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/standalone_multislice.py b/standalone_multislice.py
--- a/standalone_multislice.py	(revision 0350faff67c49af3de49e75db76320eb12264231)
+++ b/standalone_multislice.py	(date 1762340851935)
@@ -6,7 +6,7 @@
 # backend for graphic generation
 import numpy as np
 import matplotlib
-from helpers import laplace
+from helpers import *
 matplotlib.use("Qt5Agg")
 
 # use path from .env
@@ -170,6 +170,32 @@
         tmp = fft2(np.exp(1.j * cfg.sigma * potential[ii, :, :] * cfg.dz) * psi)
         psi = ifft2(tmp * prop * bwl_msk)  # Impinging wave for the next slice
 
+    return psi
+
+
+def fcms(potential, cfg):
+
+    # Precompute the bandwidth limiting mask and the Fresnel propagator
+    bwl_msk = bandwidth_limit(cfg)
+
+    # The multislice itself is surprisingly simple:
+    psi = cfg.probe  # Initialize with the probe function
+    K0 = 1 / cfg.lam
+    a = 2 * np.pi * 1.j * cfg.dz * K0
+    c = 1 / (2 * np.pi * K0)**2
+    for ii in range(cfg.shape[0]):
+        b = 1 + cfg.sigma / (np.pi * K0) * potential[ii, :, :]
+        coef0 = np.exp(a * (np.sqrt(b) - 1))
+        coef1 = a * c * np.exp(a * (np.sqrt(b) - 1)) / (2 * np.sqrt(b))
+        coef2 = a * (a * np.sqrt(b) - 1) * c**2 * np.exp(a * (np.sqrt(b) - 1)) / (8 * np.pow(b, 3/2))
+        coef3 = a * (3 - 3 * a * np.sqrt(b) + a**2 * b) * c**3 * np.exp(a * (np.sqrt(b) - 1)) / (48 * np.pow(b, 5/2))
+        term0 = coef0 * psi
+        term1 = coef1 * laplace(psi)
+        term2 = coef2 * laplace_n(psi, 2)
+        term3 = coef3 * laplace_n(psi, 3)
+        tmp = term0 + term1 + term2 + term3
+        psi = ifft2(fft2(tmp) * bwl_msk)  # Impinging wave for the next slice
+
     return psi
 
 
@@ -279,7 +305,7 @@
     # Crop the z-direction if needed
     potential = crop_z(potential, factor=20)
 
-    settings = Settings(ht=100.,  # [kV] 'high tension,' a.k.a. acceleration voltage.  Vary between 10. and 100.
+    settings = Settings(ht=10.,  # [kV] 'high tension,' a.k.a. acceleration voltage.  Vary between 10. and 100.
                         # The size and dx of the provided potential are optimized for alpha=20. Keep fixed, especially
                         # in the beginning of the assignment! Later you can vary between 10. and 30. if you're curious.
                         alpha=20.,  # [mrad] convergence angle, 20. is the default.
